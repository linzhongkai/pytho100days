Python查找一个变量时会按照“局部作用域”、“嵌套作用域”、“全局作用域”和“内置作用域”的顺序进行搜索，前三者我们在上面的
代码中已经看到了，所谓的“内置作用域”就是Python内置的那些隐含标识符min、len等都属于内置作用域）。

在实际开发中，我们应该尽量减少对全局变量的使用，因为全局变量的作用域和影响过于广泛，可能会发生意料之外的修改和使用，
除此之外全局变量比局部变量拥有更长的生命周期，可能导致对象占用的内存长时间无法被垃圾回收。事实上，减少对全局变量的使
用，也是降低代码之间耦合度的一个重要举措，同时也是对迪米特法则的践行。减少全局变量的使用就意味着我们应该尽量让变量的
作用域在函数的内部，但是如果我们希望将一个局部变量的生命周期延长，使其在函数调用结束后依然可以访问，这时候就需要使用
闭包，这个我们在后续的内容中进行讲解。
说明： 很多人经常会将“闭包”一词和“匿名函数”混为一谈，但实际上它们是不同的概念，如果想提前了解这个概念，推荐看看维基
百科或者知乎上对这个概念的讨论。

所谓字符串，就是由零个或多个字符组成的有限序列

set./list.pop()
tuple.popitem()

a_list = [x ** 2 for x in range(1, 10)]
print(a_list)
#用这种方式元素已经准备就绪，所以需要耗费较多的内存空间
#查看对象占用内存的字节数
print(sys.getsizeof(a_list))
#创建生成器对象，通过生成器可以获取到数据，但不占用额外的内存空间
a_list = (x ** 2 for x in range(1, 10))
print(a_list)
print(sys.getsizeof(a_list))
for val in a_list:
    print(val)

有了列表为什么还需要元组
1：元组的元素是无法修改的，项目在多线程环境中可能更喜欢使用的是那些不变对象，
一方面因为对象状态不能修改的，所以可以避免由此引发的不必要的程序错误，简单来
说就是更容易维护；另一个方面是因为没有任何一个线程能够修改不变对象的内部状态，
一个不变对象自动就是线程安全的，这样可以省略掉处理同步化的开销，可以方便的被
共享访问。
所以结论就是：如果不需要对元素进行添加、删除、修改的时候，可以考虑使用元组，
当然如果一个方法要返回多个值，使用元组也是不错的选择。
2：元组在创建时间和占用的空间都优先于列表。可以使用sys.getsizeof()函数来检查
占用的内存空间，创建所耗费时间可以用ipython中的%timeit来分析
%timeit [1, 2, 3]
46.1 ns ± 0.0882 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)
%timeit (1, 2, 3)
13.8 ns ± 0.097 ns per loop (mean ± std. dev. of 7 runs, 100000000 loops each)

enumerate()函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列
try_enumerate = ['linzhongkai', 'xiaolin', 'xiaokai', 'laozhong']
    enu_list = enumerate(try_enumerate)
    for val in enu_list:
        print(val, end=' ')

(0, 'linzhongkai') (1, 'xiaolin') (2, 'xiaokai') (3, 'laozhong')






####################################################
把一组数据结构和处理他们的方法组成对象(Objetct)，把相同行为的对象归纳成类，通过类的封装
(encapsulation)隐藏内部细节，通过继承(inheritance)实现类的特化(specailization)和泛化
(generalization)，通过多态(polymorphism)实现基于对象类型的动态分类。
类是对象的蓝图和模板，而对象是类的实例
在面向对象编程的世界中，一切皆为对象，对象都有属性和行为，每个对象都是独一无二的，而且对象一定属于某个类（型）
# PEP 8要求标识符的名字用全小写多个单词用下划线连接
# 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识)

对象中属性一般是私有的，方法是公共的
在实际开发中，我们并不建议将属性设置为私有的，因为这会导致子类无法访问（后面会讲到）。所以大多数Python程序员
会遵循一种命名惯例就是让属性名以单下划线开头来表示属性是受保护的
单下划线开头的属性和方法外界仍然是可以访问的，所以更多的时候它是一种暗示或隐喻，关于这一点可以看看我的《Pyth
on - 那些年我们踩过的那些坑》文章中的讲解。

面向对象有三大支柱：封装、继承和多态。
封装：只知道方法的名字和传入的尝试就可以执行方法中的代码，不需要知道方法中的具体实现代码

面向对象进阶
装饰器
虽然不建议将属性设置为私有的，但是如果将属性暴露给外界也是有问题的，比如没有办法检查赋给
属性的值是否有效。之间的建议是将属性命名暗示属性是受保护的，不建议外界访问，那么我们如果
想访问属性可以通过getter（访问器）和setter（修改器）方法进行对应的操作。可以使用@property
来包装getter和setter，使得属性安全方便
@property装饰器就是负责把一个方法变成属性调用的

python是一门动态语言（脚本语言，常见的shell脚本），只在被调用的时候进行解释和编译。
允许我们在程序运行时给对象绑定新的属性或方法，也可以相应解绑。但是如果我们需要限定自定义类型
的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的
限定只对当前类的对象生效，对子类并不起任何作用。

静态方法和类方法
@staticmethod and @classmethod
静态方法不需要创建对象就可以调用
和静态方法比较类似，Python还可以在类中定义类方法，类方法的第一个参数约定名为cls，它代表的是
当前类相关的信息的对象（类本身也是一个对象，有的地方也称之为类的元数据对象），通过这个参数我
们可以获取和类相关的信息并且可以创建出类的对象，


继承和多态
子类的初始化需要调用super().__init__(*args)
class lzk(Person):
    def __init__(self, name, age, grade):
        super().__init__(name, age)
        self._grade = grade

抽象基类，Python 对于ABC的支持模块是abc模块，
定义了一个特殊的metaclass：ABCMeta 还有一些装饰器：
@abstractmethod 和 @abstarctproperty 。
abc.ABCMeta 用于在Python程序中创建抽象基类，
而抽象基类如果想要声明“抽象方法”，可以使用 @abstractmethod ，
如果想声明“抽象属性”，可以使用 @abstractproperty 。


#############################################################
GUI编程
tkinter是python自带的
gui的开发不是python的强项，如果真的需要使用Python开发GUI应用，wxPython、PyQt、PyGTK等模块
都是不错的选择。
需要说明的是，GUI应用通常是事件驱动式的，之所以要进入主事件循环就是要监听鼠标、键盘等各种事件
的发生并执行对应的代码对事件进行处理，因为事件会持续的发生，所以需要这样的一个循环一直运行着等
待下一个事件的发生。另一方面，Tk为控件的摆放提供了三种布局管理器，通过布局管理器可以对控件进行
定位，这三种布局管理器分别是：Placer（开发者提供控件的大小和摆放位置）、Packer（自动将控件填
充到合适的位置）和Grid（基于网格坐标来摆放控件），此处不进行赘述。
pack
expand	该 bool 值指定当父容器增大时才是否拉伸组件。

##############################################################
文件和异常
实现数据持久化的最直接简单的方式就是将数据保存到文件

文件路径：
../ 表示当前文件所在的上一级目录
./ 表示当前文件所在的目录
/ 当前站点的根目录

二进制数据的读取

JSON数据
JSON	Python
object	dict
array	list
string	str
number (int / real)	int / float
true / false	True / False
null	None

json模块主要函数：
dump 将Python对象按照JSON格式序列化到文件中
dumps 将Python对象处理成JSON格式的字符串
load 将文件中的JSON数据反序列化成对象
loads 将字符串的内容反序列化成Python对象

###########################################################
正则表达式
如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用\进行转义处理，例如想匹配小数点可以写成\.就可以了，
因为直接写.会匹配任意字符；同理，想匹配圆括号必须写成\(和\)，否则圆括号被视为正则表达式中的分组。

python对正则表达式的支持
complie(pattern, flags=0)
编译正则表达式，返回正则表达式对象
match(pattern,string,flags=0)
使用正则表达式匹配字符串，成功返回匹配对象，否则返回None
search(pattern,string,flags=0)
搜索字符串中第一次出现正则表达式的模式，成功返回匹配对象，否则返回None
split(pattern,stting,flags=0)
用正则表达式指定的模式分隔符拆分字符串，返回列表
sub(pattern,repl,string,count=0,flags=0)
用指定的字符串替换原字符串中与正则表达式匹配的模型，可以用count指定替换的次数
fullmatch(pattern,string,flags=0)
match函数的完全匹配版本（从开头匹配到结尾）
findall(pattern,string,flags=0)
查找字符串中所有与正则表达式匹配的模式，返回字符串的列表
finditer(pattern, string, flags=0)
查找字符串中所有与正则表达式匹配的模式，返回一个迭代器
purge()
清楚隐式编译的正则表达式的缓存
re.l/re.IGNORECASE
忽略大小写匹配标记
re.M/re.MULTILINE
多行匹配标记

上面提到的re模块中的这些函数，实际开发中也可以用正则表达式对象的方法替代对这些函数的使用，
如果一个正则表达式需要重复的使用，那么先通过compile函数编译正则表达式并创建出正则表达式对象无疑是更为明智的选择。

########################################################
进程和线程
不管用什么编程语言进行开发，实现让程序同时执行多个任务，也就是常说的
'并发编程'，应该是每个程序员必备技能之一，讨论两个概念。

进程：
操作系统中执行的一个程序，操作系统以进程为单位分配存储空间，每个进程都有自己的
地址空间，数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，
为他们合理分配资源，进程可以通过fork或spawn的方式创建新的进程来执行其他的任务，
不过新的进程也有自己的内存空间，因此进程间通信机制（IPC:inter-process communication）
来实现数据共享，具体的方式：管道，信号，套接字，共享内存区等

一个进程还可以拥有多个并发的执行线索，简单的说就是拥有多个可以获得CPU调度的执行单元，
这就是所谓的线程。

当然在单核CPU系统中，真正的并发是不可能的，因为在某个时刻能够获得CPU的只有唯一的一个线程，
多个线程共享了CPU的执行时间。使用多线程实现并发编程为程序带来的好处是不言而喻的，最主要的
体现在提升程序的性能和改善用户体验，今天我们使用的软件几乎都用到了多线程技术

########
当然多线程也并不是没有坏处，站在其他进程的角度，多线程的程序对其他程序并不友好，因为它占用
了更多的CPU执行时间，导致其他程序无法获得足够的CPU执行时间；另一方面，站在开发者的角度，编
写和调试多线程的程序都对开发者有较高的要求，对于初学者来说更加困难。

Python实现并发编程主要有3种方式：多进程、多线程、多进程+多线程。

比较遗憾的一件事情是Python的多线程并不能发挥CPU的多核特性，这一点只要启动几个执行死循环的线程
就可以得到证实了。之所以如此，是因为Python的解释器有一个“全局解释器锁”（GIL）的东西，任何线程
执行前必须先获得GIL锁，然后每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行，这
是一个历史遗留问题，但是即便如此，就如我们之前举的例子，使用多线程在提升执行效率和改善用户体验
方面仍然是有积极意义的。

计算密集型和IO密集型
计算密集型需要大量的计算，消耗cpu的资源，比如对视频进行编解码或格式转换等
最能胜任这种任务的是C语言，python有嵌入C/C++代码的机制
其他的涉及到网络，存储介质IO的任务都可以视为IO密集型任务，这类任务的特点是消耗cpu很少
务的大部分时间都在等待I/O操作完成（因为I/O的速度远远低于CPU和内存的速度）。对于I/O密集型任务，
如果启动多任务，就可以减少I/O等待时间从而让CPU高效率的运转。有一大类的任务都属于I/O密集型任务，
这其中包括了我们很快会涉及到的网络应用和Web应用。

###########
单线程和异步IO
如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型执行多任务，这种全新的模型称为事件驱动。
在python中，单线程+异步IO的编程模型被称为协程，有了协程的支持就可以基于事件驱动编写高效的多任务程序
协程最大的优势就是极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换
的开销。协程的第二个优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中
控制共享资源不用加锁，只需要判断状态就好了，所以执行效率比多线程高很多。如果想要充分利用CPU的多核特性，
最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能