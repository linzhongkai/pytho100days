Python查找一个变量时会按照“局部作用域”、“嵌套作用域”、“全局作用域”和“内置作用域”的顺序进行搜索，前三者我们在上面的
代码中已经看到了，所谓的“内置作用域”就是Python内置的那些隐含标识符min、len等都属于内置作用域）。

在实际开发中，我们应该尽量减少对全局变量的使用，因为全局变量的作用域和影响过于广泛，可能会发生意料之外的修改和使用，
除此之外全局变量比局部变量拥有更长的生命周期，可能导致对象占用的内存长时间无法被垃圾回收。事实上，减少对全局变量的使
用，也是降低代码之间耦合度的一个重要举措，同时也是对迪米特法则的践行。减少全局变量的使用就意味着我们应该尽量让变量的
作用域在函数的内部，但是如果我们希望将一个局部变量的生命周期延长，使其在函数调用结束后依然可以访问，这时候就需要使用
闭包，这个我们在后续的内容中进行讲解。
说明： 很多人经常会将“闭包”一词和“匿名函数”混为一谈，但实际上它们是不同的概念，如果想提前了解这个概念，推荐看看维基
百科或者知乎上对这个概念的讨论。

所谓字符串，就是由零个或多个字符组成的有限序列

set./list.pop()
tuple.popitem()

a_list = [x ** 2 for x in range(1, 10)]
print(a_list)
#用这种方式元素已经准备就绪，所以需要耗费较多的内存空间
#查看对象占用内存的字节数
print(sys.getsizeof(a_list))
#创建生成器对象，通过生成器可以获取到数据，但不占用额外的内存空间
a_list = (x ** 2 for x in range(1, 10))
print(a_list)
print(sys.getsizeof(a_list))
for val in a_list:
    print(val)

有了列表为什么还需要元组
1：元组的元素是无法修改的，项目在多线程环境中可能更喜欢使用的是那些不变对象，
一方面因为对象状态不能修改的，所以可以避免由此引发的不必要的程序错误，简单来
说就是更容易维护；另一个方面是因为没有任何一个线程能够修改不变对象的内部状态，
一个不变对象自动就是线程安全的，这样可以省略掉处理同步化的开销，可以方便的被
共享访问。
所以结论就是：如果不需要对元素进行添加、删除、修改的时候，可以考虑使用元组，
当然如果一个方法要返回多个值，使用元组也是不错的选择。
2：元组在创建时间和占用的空间都优先于列表。可以使用sys.getsizeof()函数来检查
占用的内存空间，创建所耗费时间可以用ipython中的%timeit来分析
%timeit [1, 2, 3]
46.1 ns ± 0.0882 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)
%timeit (1, 2, 3)
13.8 ns ± 0.097 ns per loop (mean ± std. dev. of 7 runs, 100000000 loops each)

enumerate()函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列
try_enumerate = ['linzhongkai', 'xiaolin', 'xiaokai', 'laozhong']
    enu_list = enumerate(try_enumerate)
    for val in enu_list:
        print(val, end=' ')

(0, 'linzhongkai') (1, 'xiaolin') (2, 'xiaokai') (3, 'laozhong')






####################################################
把一组数据结构和处理他们的方法组成对象(Objetct)，把相同行为的对象归纳成类，通过类的封装
(encapsulation)隐藏内部细节，通过继承(inheritance)实现类的特化(specailization)和泛化
(generalization)，通过多态(polymorphism)实现基于对象类型的动态分类。
类是对象的蓝图和模板，而对象是类的实例
在面向对象编程的世界中，一切皆为对象，对象都有属性和行为，每个对象都是独一无二的，而且对象一定属于某个类（型）
# PEP 8要求标识符的名字用全小写多个单词用下划线连接
# 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识)

对象中属性一般是私有的，方法是公共的
在实际开发中，我们并不建议将属性设置为私有的，因为这会导致子类无法访问（后面会讲到）。所以大多数Python程序员
会遵循一种命名惯例就是让属性名以单下划线开头来表示属性是受保护的
单下划线开头的属性和方法外界仍然是可以访问的，所以更多的时候它是一种暗示或隐喻，关于这一点可以看看我的《Pyth
on - 那些年我们踩过的那些坑》文章中的讲解。

面向对象有三大支柱：封装、继承和多态。
封装：只知道方法的名字和传入的尝试就可以执行方法中的代码，不需要知道方法中的具体实现代码

面向对象进阶
装饰器
虽然不建议将属性设置为私有的，但是如果将属性暴露给外界也是有问题的，比如没有办法检查赋给
属性的值是否有效。之间的建议是将属性命名暗示属性是受保护的，不建议外界访问，那么我们如果
想访问属性可以通过getter（访问器）和setter（修改器）方法进行对应的操作。可以使用@property
来包装getter和setter，使得属性安全方便
@property装饰器就是负责把一个方法变成属性调用的

python是一门动态语言（脚本语言，常见的shell脚本），只在被调用的时候进行解释和编译。
允许我们在程序运行时给对象绑定新的属性或方法，也可以相应解绑。但是如果我们需要限定自定义类型
的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的
限定只对当前类的对象生效，对子类并不起任何作用。


